<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Plotter Developer's Guide</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="intro/introduction.html"><strong aria-hidden="true">1.</strong> Plotters Developer's Guide</a></li><li><ol class="section"><li class="expanded "><a href="intro/getting_started.html"><strong aria-hidden="true">1.1.</strong> Getting started</a></li></ol></li><li class="expanded "><a href="basic/overview.html"><strong aria-hidden="true">2.</strong> Basic plotting</a></li><li><ol class="section"><li class="expanded "><a href="basic/chart_context.html"><strong aria-hidden="true">2.1.</strong> Define chart context</a></li><li class="expanded "><a href="basic/chart_components.html"><strong aria-hidden="true">2.2.</strong> Draw figure components</a></li><li class="expanded "><a href="basic/basic_data_plotting.html"><strong aria-hidden="true">2.3.</strong> Basic data plotting</a></li><li class="expanded "><a href="basic/multipanel.html"><strong aria-hidden="true">2.4.</strong> Multipanel figures</a></li><li class="expanded "><a href="basic/draw_3d_plots.html"><strong aria-hidden="true">2.5.</strong> Draw 3D plots</a></li><li class="expanded "><a href="basic/animate.html"><strong aria-hidden="true">2.6.</strong> Animation and realtime rendering</a></li></ol></li><li class="expanded "><a href="tweak/overview.html"><strong aria-hidden="true">3.</strong> Tweaking the figure</a></li><li><ol class="section"><li class="expanded "><a href="tweak/layout.html"><strong aria-hidden="true">3.1.</strong> Layout tweak</a></li><li class="expanded "><a href="tweak/font_color_style.html"><strong aria-hidden="true">3.2.</strong> Font, color and styles</a></li><li class="expanded "><a href="tweak/aixs_mesh_labels.html"><strong aria-hidden="true">3.3.</strong> Axis, mesh and label tweaks</a></li><li class="expanded "><a href="tweak/relative_sizing.html"><strong aria-hidden="true">3.4.</strong> Relative sizing</a></li></ol></li><li class="expanded "><a href="drawing/overview.html"><strong aria-hidden="true">4.</strong> Drawing APIs</a></li><li><ol class="section"><li class="expanded "><a href="drawing/drawing_area.html"><strong aria-hidden="true">4.1.</strong> Drawing areas</a></li><li class="expanded "><a href="drawing/elements.html"><strong aria-hidden="true">4.2.</strong> Elements</a></li></ol></li><li class="expanded "><a href="coord/coord_system.html"><strong aria-hidden="true">5.</strong> Coordinate systems</a></li><li><ol class="section"><li class="expanded "><a href="coord/one_diml.html"><strong aria-hidden="true">5.1.</strong> 1D coordinates</a></li><li class="expanded "><a href="coord/high_dim.html"><strong aria-hidden="true">5.2.</strong> High dimensional coordinates</a></li><li class="expanded "><a href="coord/coord_combinators.html"><strong aria-hidden="true">5.3.</strong> Coordinate combinators</a></li></ol></li><li class="expanded "><a href="backends/overview.html"><strong aria-hidden="true">6.</strong> Targeting different backends</a></li><li><ol class="section"><li class="expanded "><a href="backends/backends.html"><strong aria-hidden="true">6.1.</strong> Drawing backends</a></li><li class="expanded "><a href="backends/canvas_backend.html"><strong aria-hidden="true">6.2.</strong> HTML5 Canvas</a></li><li class="expanded "><a href="backends/fb.html"><strong aria-hidden="true">6.3.</strong> Framebuffer</a></li></ol></li><li class="expanded "><a href="perf/overview.html"><strong aria-hidden="true">7.</strong> Performance</a></li><li><ol class="section"><li class="expanded "><a href="perf/parallel_blit.html"><strong aria-hidden="true">7.1.</strong> Parallel Rendering with Bitmap Blit</a></li><li class="expanded "><a href="perf/inplace_rendering.html"><strong aria-hidden="true">7.2.</strong> Inplace Parallel Rendering</a></li><li class="expanded "><a href="perf/incremental_rendering.html"><strong aria-hidden="true">7.3.</strong> Incremental Rendering</a></li></ol></li><li class="expanded "><a href="extend/overview.html"><strong aria-hidden="true">8.</strong> Extend Plotters</a></li><li><ol class="section"><li class="expanded "><a href="extend/coord.html"><strong aria-hidden="true">8.1.</strong> Adding coordinate type</a></li><li class="expanded "><a href="extend/series.html"><strong aria-hidden="true">8.2.</strong> Adding series types</a></li><li class="expanded "><a href="extend/backend.html"><strong aria-hidden="true">8.3.</strong> Support new backend</a></li></ol></li><li class="expanded "><a href="appendix/index.html"><strong aria-hidden="true">9.</strong> Appendix</a></li><li><ol class="section"><li class="expanded "><a href="appendix/supported_backends.html"><strong aria-hidden="true">9.1.</strong> Supported backends</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Plotter Developer's Guide</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#plotters-developer-guide" id="plotters-developer-guide">Plotters Developer Guide</a></h1>
<p>Plotters is a drawing library aimed to expedite the production of high-quality data visualization in Rust.</p>
<p>Plotters has a high-level, easy-to-use API for data visualization use case. It's designed to be highly flexible and extensible. As a drawing library, Plotters doesn't limit user to particular types of visualization. You can easily create your own data visulization with Plotters API.</p>
<p>Plotters can target wide range of backends and supports both static and realtime rendering. Plotters fits many different use cases, include:</p>
<ul>
<li>Producing publication figure,</li>
<li>Realtime data visualization on an embeded device,</li>
<li>Plot widget for GUI frameworks,</li>
<li>Web pages,</li>
<li>And more.</li>
</ul>
<h2><a class="header" href="#source-code-in-this-book" id="source-code-in-this-book">Source code in this book</a></h2>
<p>Please go to <a href="https://github.com/plotters-rs/guide">Github repository</a>. All the sample code is under <code>examples</code>
directory. 
To try it yourself, please clone the book repo and use the following command to run all examples:</p>
<pre><code class="language-bash">cargo test 
</code></pre>
<p>And all the example code will be automatically extracted to the <code>src</code> directory.</p>
<h3><a class="header" href="#faq-list" id="faq-list">FAQ List</a></h3>
<ol>
<li>
<p>Why the example just exits without any figure popping up?</p>
<p>You should be table to find the output under <code>images</code> directory under the user's guide repository. 
The filename for the output is the defined in the example code.</p>
</li>
</ol>
<h2><a class="header" href="#api-docs" id="api-docs">API Docs</a></h2>
<p>This book is a developer's guide for Plotters. You may also want the API reference, please go to <a href="https://docs.rs/plotters">docs.rs</a>.</p>
<h2><a class="header" href="#interactive-tutorial" id="interactive-tutorial">Interactive Tutorial</a></h2>
<p>There's an interactive tutorial with Jupyter notebook + excvr availible, feel free to check the <a href="https://plotters-rs.github.io/plotters-doc-data/evcxr-jupyter-integration.html">statically rendered notebook</a>
and follow the instruction to setup the interactive tutorial on your local.</p>
<h2><a class="header" href="#license-and-source-code" id="license-and-source-code">License and Source Code</a></h2>
<p>Plotters is a free and open source software under <a href="https://github.com/38/plotters/blob/master/LICENSE">MIT license</a>. </p>
<p>You can find the source code on our <a href="https://github.com/38/plotters">Github repository</a>. 
Currently Plotters is actively maintained and envolving very fast. Any involement, 
including PR, suggestion, idea and issue is warmly welcomed.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>Let's have a quick walk through on how to produce a data plot with Plotters.
This is an example that plotting the graph of a simple equation <code>y = sin(x)</code> to a PNG file.</p>
<h2><a class="header" href="#step-0---install-prerequisite-libraries-to-system" id="step-0---install-prerequisite-libraries-to-system">Step 0 - Install prerequisite libraries to system</a></h2>
<p>Plotters may use some library installed on your system, depends on what operating system you are using.</p>
<ul>
<li>
<p>For Linux user: please make sure <code>libfontconfig</code> package is installed. For Ubuntu/Debian user, use the following
command to install them.</p>
<pre><code class="language-bash">sudo apt-get install libfontconfig libfontconfig1-dev
</code></pre>
</li>
<li>
<p>For Windows and OSX user: No prerequisite library is required.</p>
</li>
</ul>
<h2><a class="header" href="#step-1---add-dependency-to-cargotoml" id="step-1---add-dependency-to-cargotoml">Step 1 - Add dependency to <code>cargo.toml</code></a></h2>
<p>In order to use Plotters, add the following line to your <code>cargo.tmol</code></p>
<pre><code class="language-toml">[dependencies]
plotters = &quot;0.3&quot;
</code></pre>
<p>Alternatively if you have <a href="https://github.com/killercup/cargo-edit">cargo-edit</a>, use the following command
to add the dependency</p>
<pre><code class="language-bash">cargo add plotters
</code></pre>
<h3><a class="header" href="#step-2---add-plotting-code" id="step-2---add-plotting-code">Step 2 - Add plotting code</a></h3>
<p>As an example, we provide a minimal code that draws the function graph.
We can just simply put the following code to the <code>src/main.rs</code></p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
    let root_drawing_area = BitMapBackend::new(&quot;images/0.1.png&quot;, (1024, 768))
        .into_drawing_area();

    root_drawing_area.fill(&amp;WHITE).unwrap();

    let mut chart = ChartBuilder::on(&amp;root_drawing_area)
        .build_cartesian_2d(-3.14..3.14, -1.2..1.2)
        .unwrap();

    chart.draw_series(LineSeries::new(
        (-314..314).map(|x| x as f64 / 100.0).map(|x| (x, x.sin())),
        &amp;RED
    )).unwrap();
}
</code></pre></pre>
<h2><a class="header" href="#step-3---build-and-run" id="step-3---build-and-run">Step 3 - Build and run</a></h2>
<p>Use the following command to build and run the example</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>And the output will be saved under the current working directory with the file name <code>/images/0.1.png</code>.</p>
<p><img src="intro/../../images/0.1.png" alt="0.1.png" /></p>
<h1><a class="header" href="#basic-plotting" id="basic-plotting">Basic plotting</a></h1>
<p>In this chapter, let's go through the basic functionality of Plotters. 
We are going to focus on how to setup the plotting environment and produce
different types of data plots, creating static, animated or realtime data visualizations.</p>
<p>The following chapter has more detailed introduction on tweaking the chart.</p>
<h1><a class="header" href="#define-chart-context" id="define-chart-context">Define chart context</a></h1>
<p>As we preivously mentioned, Plotters is drawing library. In theory, you should be able to draw any data plot based on the Plotters drawing API. On the top of drawing API, we provide the chart context, which creates a friendly environment for data visualization.</p>
<h2><a class="header" href="#create-a-chart-context-from-a-drwaing-area" id="create-a-chart-context-from-a-drwaing-area">Create a chart context from a drwaing area</a></h2>
<p><code>ChartBuilder</code> is the builder type to create a chart context.</p>
<p>The following code shows how to make a chart context that is using a 
2D cartesian coordinate in which both X and Y axis is ranged 0 to 100.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
  let drawing_area = BitMapBackend::new(&quot;images/2.0.png&quot;, (1024, 768))
    .into_drawing_area();
  
  let _chart = ChartBuilder::on(&amp;drawing_area)
    .build_cartesian_2d(0..100, 0..100)
    .unwrap();
}
</code></pre></pre>
<h2><a class="header" href="#draw-series-on-to-the-chart-context" id="draw-series-on-to-the-chart-context">Draw series on to the chart context</a></h2>
<p>Once we have the chart context, we can put series on it. 
In this example, we use the <code>LineSeries</code> type to draw a line series on the
chart. </p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
  let drawing_area = BitMapBackend::new(&quot;images/2.1.png&quot;, (600, 400))
    .into_drawing_area();

  drawing_area.fill(&amp;WHITE).unwrap();
  
  let mut chart = ChartBuilder::on(&amp;drawing_area)
    .build_cartesian_2d(0..100, 0..100)
    .unwrap();

  chart.draw_series(
    LineSeries::new((0..100).map(|x| (x, 100 - x)), &amp;BLACK),
  ).unwrap();
}
</code></pre></pre>
<p>This code will produce the following figure. </p>
<p><img src="basic/../../images/2.1.png" alt="exampe-2.1" /></p>
<h1><a class="header" href="#draw-figure-components" id="draw-figure-components">Draw figure components</a></h1>
<p>For most of the time, the chart should have many components, such as the axis, the mesh grid, etc. The <code>ChartContext</code> type is able to draw those component automatically.</p>
<h2><a class="header" href="#mesh" id="mesh">Mesh</a></h2>
<p>The following code demonstrate how we can use <code>ChartContext::configure_mesh</code> to add a mesh to the chart.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
  let root_drawing_area = BitMapBackend::new(&quot;images/2.2.png&quot;, (600, 400))
    .into_drawing_area();

  root_drawing_area.fill(&amp;WHITE).unwrap();

  let mut ctx = ChartBuilder::on(&amp;root_drawing_area)
    .build_cartesian_2d(0..100, 0..100)
    .unwrap();

  ctx.configure_mesh().draw().unwrap();

}
</code></pre></pre>
<p>And this code should produce the following result.</p>
<p><img src="basic/../../images/2.2.png" alt="example-2-2" /></p>
<h2><a class="header" href="#axes" id="axes">Axes</a></h2>
<p>To add axes to the plot, it requires two steps:</p>
<ol>
<li>Define the label area size when the <code>ChartContext</code> is created.</li>
<li>Use <code>configure_mesh</code> to draw the chart components.</li>
</ol>
<p>The following code demonstrates how to add axes</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
  let root_drawing_area = BitMapBackend::new(&quot;images/2.3.png&quot;, (600, 400))
    .into_drawing_area();

  root_drawing_area.fill(&amp;WHITE).unwrap();

  let mut ctx = ChartBuilder::on(&amp;root_drawing_area)
    // enables Y axis, the size is 40 px
    .set_label_area_size(LabelAreaPosition::Left, 40)
    // enable X axis, the size is 40 px
    .set_label_area_size(LabelAreaPosition::Bottom, 40)
    .build_cartesian_2d(0..100, 0..100)
    .unwrap();

  ctx.configure_mesh().draw().unwrap();

}
</code></pre></pre>
<p>The code above will result:</p>
<p><img src="basic/../../images/2.3.png" alt="2.3.png" /></p>
<h2><a class="header" href="#title" id="title">Title</a></h2>
<p>The following example shows how to add title to the plot with <code>ChartBuilder::caption</code>.</p>
<p>In Plotters the most common way to represent a font is use a tuple of font face name and
font size.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
  let root_drawing_area = BitMapBackend::new(&quot;images/2.4.png&quot;, (600, 400))
    .into_drawing_area();

  root_drawing_area.fill(&amp;WHITE).unwrap();

  let mut ctx = ChartBuilder::on(&amp;root_drawing_area)
    .caption(&quot;Figure Sample&quot;, (&quot;Arial&quot;, 30))
    .set_label_area_size(LabelAreaPosition::Left, 40)
    .set_label_area_size(LabelAreaPosition::Bottom, 40)
    .build_cartesian_2d(0..100, 0..100)
    .unwrap();

  ctx.configure_mesh().draw().unwrap();

}
</code></pre></pre>
<p>The code above will result:</p>
<p><img src="basic/../../images/2.4.png" alt="2.4.png" /></p>
<h1><a class="header" href="#basic-data-plotting" id="basic-data-plotting">Basic data plotting</a></h1>
<p>In this section, let's use Plotters to produce different types of Plotting. Generally speaking, the API <code>ChartContext::draw_series</code> provides the functionality to draw any types of chart. In the following parts, let's discuss how to use it to render different types of plots.</p>
<h2><a class="header" href="#line-series" id="line-series">Line series</a></h2>
<p>The following code demonstrate how to draw a line series with Plotters</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
  let root_area = BitMapBackend::new(&quot;images/2.5.png&quot;, (600, 400))
    .into_drawing_area();
  root_area.fill(&amp;WHITE).unwrap();

  let mut ctx = ChartBuilder::on(&amp;root_area)
    .set_label_area_size(LabelAreaPosition::Left, 40)
    .set_label_area_size(LabelAreaPosition::Bottom, 40)
    .caption(&quot;Line Plot Demo&quot;, (&quot;sans-serif&quot;, 40))
    .build_cartesian_2d(-10..10, 0..100)
    .unwrap();

  ctx.configure_mesh().draw().unwrap();

  ctx.draw_series(
    LineSeries::new((-10..=10).map(|x| (x, x* x)), &amp;GREEN)
  ).unwrap();
}
</code></pre></pre>
<p>It should produce the following image</p>
<p><img src="basic/../../images/2.5.png" alt="2.5.png" /></p>
<h2><a class="header" href="#scatter-plot" id="scatter-plot">Scatter Plot</a></h2>
<p>The following code demonstrate how we can crate a scatter plot and use different pointing elements. In the example, we use <code>Circle</code> and <code>TriangleMarker</code> pointing element for two different series.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
    let root_area = BitMapBackend::new(&quot;images/2.6.png&quot;, (600, 400))
    .into_drawing_area();
    root_area.fill(&amp;WHITE).unwrap();

    let mut ctx = ChartBuilder::on(&amp;root_area)
        .set_label_area_size(LabelAreaPosition::Left, 40)
        .set_label_area_size(LabelAreaPosition::Bottom, 40)
        .caption(&quot;Scatter Demo&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_2d(-10..50, -10..50)
        .unwrap();

    ctx.configure_mesh().draw().unwrap();

    ctx.draw_series(
        DATA1.iter().map(|point| TriangleMarker::new(*point, 5, &amp;BLUE)),
    )
    .unwrap();

    ctx.draw_series(DATA2.iter().map(|point| Circle::new(*point, 5, &amp;RED)))
        .unwrap();
}
const DATA1: [(i32, i32); 30] =  [(-3, 1), (-2, 3), (4, 2), (3, 0), (6, -5), (3, 11), (6, 0), (2, 14), (3, 9), (14, 7), (8, 11), (10, 16), (7, 15), (13, 8), (17, 14), (13, 17), (19, 11), (18, 8), (15, 8), (23, 23), (15, 20), (22, 23), (22, 21), (21, 30), (19, 28), (22, 23), (30, 23), (26, 35), (33, 19), (26, 19)];
const DATA2: [(i32, i32); 30] = [(1, 22), (0, 22), (1, 20), (2, 24), (4, 26), (6, 24), (5, 27), (6, 27), (7, 27), (8, 30), (10, 30), (10, 33), (12, 34), (13, 31), (15, 35), (14, 33), (17, 36), (16, 35), (17, 39), (19, 38), (21, 38), (22, 39), (23, 43), (24, 44), (24, 46), (26, 47), (27, 48), (26, 49), (28, 47), (28, 50)];
</code></pre></pre>
<p>And this will produce the following image.</p>
<p><img src="basic/../../images/2.6.png" alt="2.6.png" /></p>
<h2><a class="header" href="#area-chart" id="area-chart">Area chart</a></h2>
<p>The following demo demonstrate how we can draw an area chart.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
    let root_area = BitMapBackend::new(&quot;images/2.7.png&quot;, (600, 400))
    .into_drawing_area();
    root_area.fill(&amp;WHITE).unwrap();

    let mut ctx = ChartBuilder::on(&amp;root_area)
        .set_label_area_size(LabelAreaPosition::Left, 40)
        .set_label_area_size(LabelAreaPosition::Bottom, 40)
        .caption(&quot;Scatter Demo&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_2d(0..10, 0..50)
        .unwrap();

    ctx.configure_mesh().draw().unwrap();

  let data = [25, 37, 15, 32, 45, 33, 32, 10, 29, 0, 21];

    ctx.draw_series(
      AreaSeries::new(
        (0..).zip(data.iter().map(|x| *x)), // The data iter
        0,                                  // Baseline
        &amp;RED.mix(0.2) // Make the series opac
      ).border_style(&amp;RED) // Make a brighter border
    )
    .unwrap();
}
</code></pre></pre>
<p>Result image:</p>
<p><img src="basic/../../images/2.7.png" alt="2.7.png" /></p>
<h2><a class="header" href="#histogram" id="histogram">Histogram</a></h2>
<p>In practice, the histogram can be two things:</p>
<ol>
<li>A bar plot</li>
<li>Or a bar plot that shows the distribution of values</li>
</ol>
<p>For a bar plot, we can simply create with a iterator that yields a series of rectangle. The following code demonstrates how. The function <code>Rectangle::margin</code> is used to set a pixel based margin for the rectangle element.</p>
<p>One note here is we used tweaked the coordinate a little bit, we make the X coordinate segmented, so that the axis labels presents in the middle of the value segments. In plotters this is called a coordinate combinator, we are going to discuss the combinators in detail in the next chapter.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
    let root_area = BitMapBackend::new(&quot;images/2.8.png&quot;, (600, 400))
    .into_drawing_area();
    root_area.fill(&amp;WHITE).unwrap();

    let mut ctx = ChartBuilder::on(&amp;root_area)
        .set_label_area_size(LabelAreaPosition::Left, 40)
        .set_label_area_size(LabelAreaPosition::Bottom, 40)
        .caption(&quot;Bar Demo&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_2d((0..10).into_segmented(), 0..50)
        .unwrap();

    ctx.configure_mesh().draw().unwrap();

    let data = [25, 37, 15, 32, 45, 33, 32, 10, 0, 21, 5];

    ctx.draw_series((0..).zip(data.iter()).map(|(x, y)| {
        let x0 = SegmentValue::Exact(x);
        let x1 = SegmentValue::Exact(x + 1);
        let mut bar = Rectangle::new([(x0, 0), (x1, *y)], RED.filled());
        bar.set_margin(0, 0, 5, 5);
        bar
    }))
    .unwrap();
}
</code></pre></pre>
<p>Result image:</p>
<p><img src="basic/../../images/2.8.png" alt="2.8.png" /></p>
<p>Similarly, the following code draws a vertical bar chart.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
    let root_area = BitMapBackend::new(&quot;images/2.9.png&quot;, (600, 400))
    .into_drawing_area();
    root_area.fill(&amp;WHITE).unwrap();

    let mut ctx = ChartBuilder::on(&amp;root_area)
        .set_label_area_size(LabelAreaPosition::Left, 40)
        .set_label_area_size(LabelAreaPosition::Bottom, 40)
        .caption(&quot;Bar Demo&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_2d(0..50, (0..10).into_segmented())
        .unwrap();

    ctx.configure_mesh().draw().unwrap();

    let data = [25, 37, 15, 32, 45, 33, 32, 10, 0, 21, 5];

    ctx.draw_series((0..).zip(data.iter()).map(|(y, x)| {
        let mut bar = Rectangle::new([
            (0, SegmentValue::Exact(y)), 
            (*x, SegmentValue::Exact(y + 1))
        ], GREEN.filled());
        bar.set_margin(5, 5, 0, 0);
        bar
    }))
    .unwrap();
}
</code></pre></pre>
<p>Result image:</p>
<p><img src="basic/../../images/2.9.png" alt="2.9.png" /></p>
<p>For the second type of histogram, there's a <code>Histogram</code> series type is defined for this purpose.</p>
<h3><a class="header" href="#visualize-distribution" id="visualize-distribution">Visualize distribution</a></h3>
<p>Now we are going to demonstrate how we can use the <code>Histogram</code> series to visualize the distribution of the input data. </p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn is_prime(n: i32) -&gt; bool {
    for i in 2..n {
        if n % i == 0 {
            return false;
        }
    }
    true
}

fn main() {
    let root_area = BitMapBackend::new(&quot;images/2.13.png&quot;, (600, 400))
    .into_drawing_area();
    root_area.fill(&amp;WHITE).unwrap();

    let mut ctx = ChartBuilder::on(&amp;root_area)
        .set_label_area_size(LabelAreaPosition::Left, 40)
        .set_label_area_size(LabelAreaPosition::Bottom, 40)
        .caption(&quot;Prime Distribution&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_2d([true, false].into_segmented(), 0..50)
        .unwrap();

    ctx.configure_mesh().draw().unwrap();

    let prim:Vec&lt;_&gt; = (2..50).map(is_prime).collect();

    ctx.draw_series(
        Histogram::vertical(&amp;ctx)
        .margin(100)
        .data(prim.iter().map(|x| (x, 1)))
    ).unwrap();
}
</code></pre></pre>
<p><img src="basic/../../images/2.13.png" alt="2.13.png" /></p>
<h2><a class="header" href="#time-series-chart" id="time-series-chart">Time Series Chart</a></h2>
<p>In theory Plotters supports any data type to be axis. The only requirement is to implement the
axis mapping traits. By default, Plotters has built-in implementation of axis traits for date and
time types. To make a time series chart, you should first import the chrono crate and define a time
range as axis.
The following example shows how we can plot a time series data.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;
use chrono::{Utc, TimeZone};

fn main() {
  let root_area = BitMapBackend::new(&quot;images/2.11.png&quot;, (600, 400))
    .into_drawing_area();
  root_area.fill(&amp;WHITE).unwrap();

  let start_date = Utc.ymd(2019, 10, 1);
  let end_date = Utc.ymd(2019, 10, 18);

    let mut ctx = ChartBuilder::on(&amp;root_area)
        .set_label_area_size(LabelAreaPosition::Left, 40)
        .set_label_area_size(LabelAreaPosition::Bottom, 40)
        .caption(&quot;MSFT daily close price&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_2d(start_date..end_date, 130.0..145.0)
        .unwrap();

    ctx.configure_mesh().draw().unwrap();

    ctx.draw_series(
        LineSeries::new(
            (0..).zip(DATA.iter()).map(|(idx, price)| {
                let day = (idx / 5) * 7 + idx % 5 + 1;
                let date = Utc.ymd(2019,10, day);
                (date, *price)
            }),
            &amp;BLUE,
        )
    ).unwrap();

}
const DATA: [f64; 14] = [ 137.24, 136.37, 138.43, 137.41, 139.69, 140.41, 141.58, 139.55, 139.68, 139.10, 138.24, 135.67, 137.12, 138.12];
</code></pre></pre>
<p>Result image:</p>
<p><img src="basic/../../images/2.11.png" alt="2.11.png" /></p>
<h2><a class="header" href="#customized-series" id="customized-series">Customized series</a></h2>
<p>Plotters allows you draw arbitrary types of series, even the one isn't built into the Plotters crate. Plotters uses a really simple abstraction for a data series: An iterator of drawable elements. Thus if you can make your own series an iterator of drawable element, it's a valid data series and can be
draw on a figure.</p>
<h2><a class="header" href="#multiple-data-series" id="multiple-data-series">Multiple Data Series</a></h2>
<p>By calling <code>draw_series</code> multiple time, Plotters is able to produce the multiple series plot. Thus, we don't limit the developer's ability to put different types of plot series onto the same plot. The following example shows plotting a histogram along with a line plot.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
    let root_area = BitMapBackend::new(&quot;images/2.10.png&quot;, (600, 400))
    .into_drawing_area();
    root_area.fill(&amp;WHITE).unwrap();

    let mut ctx = ChartBuilder::on(&amp;root_area)
        .set_label_area_size(LabelAreaPosition::Left, 40)
        .set_label_area_size(LabelAreaPosition::Bottom, 40)
        .caption(&quot;Histo + Line&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_2d(0..10, 0..80)
        .unwrap();

    ctx.configure_mesh().draw().unwrap();

    let data = [25, 37, 15, 32, 45, 33, 32, 10, 0, 21];

    // Draw the histogram
    ctx.draw_series((0..).zip(data.iter()).map(|(x, y)| {
        let mut bar = Rectangle::new([(x, 0), (x + 1, *y)], GREEN.filled());
        bar.set_margin(0, 0, 5, 5);
        bar
    }))
    .unwrap();

    // Draw the line series
    ctx.draw_series(LineSeries::new(
        (0..).zip(data.iter()).map(|(x, y)| (x, *y + 30)),
        &amp;BLUE,
    ))
    .unwrap();
}
</code></pre></pre>
<p>Result image:</p>
<p><img src="basic/../../images/2.10.png" alt="2.10.png" /></p>
<h2><a class="header" href="#legend" id="legend">Legend</a></h2>
<p>Plotters allows user add legend on the figure. Specifically, Plotters called the it &quot;series label&quot;. When you call <code>ChartContext::draw_series</code>, a result type that carries a handle to a series annotation is returned and you can use it to add a series label to that. After you complete the data plotting, <code>ChartContext::configure_series_label</code> can be called to configure and draw the collections of series label. The following example demonstrate how.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
    let root_area = BitMapBackend::new(&quot;images/2.12.png&quot;, (600, 400))
    .into_drawing_area();
    root_area.fill(&amp;WHITE).unwrap();

    let mut ctx = ChartBuilder::on(&amp;root_area)
        .set_label_area_size(LabelAreaPosition::Left, 40)
        .set_label_area_size(LabelAreaPosition::Bottom, 40)
        .caption(&quot;Legend&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_2d(-4.0..4.0, -1.2..1.2)
        .unwrap();

    ctx.configure_mesh().draw().unwrap();

    let x_kps: Vec&lt;_&gt; = (-80..80).map(|x| x as f64 / 20.0).collect();
    ctx.draw_series(LineSeries::new(x_kps.iter().map(|x| (*x, x.sin())), &amp;RED))
        .unwrap()
        .label(&quot;Sine&quot;)
        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &amp;RED));

    ctx.draw_series(LineSeries::new(x_kps.iter().map(|x| (*x, x.cos())), &amp;BLUE))
        .unwrap()
        .label(&quot;Cosine&quot;)
        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &amp;BLUE));

    ctx.configure_series_labels()
        .border_style(&amp;BLACK)
        .background_style(&amp;WHITE.mix(0.8))
        .draw()
        .unwrap();
}
</code></pre></pre>
<p>Result image:</p>
<p><img src="basic/../../images/2.12.png" alt="2.12.png" /></p>
<h1><a class="header" href="#multipanel-figures" id="multipanel-figures">Multipanel figures</a></h1>
<h2><a class="header" href="#splitting-drawing-areas" id="splitting-drawing-areas">Splitting drawing areas</a></h2>
<p>Plotters can support multiple panel figures very easily by splitting the drawing area into sub-drawing areas. The following code demonstrate how the drawing area is splitted. </p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;
fn main() {
    let root = BitMapBackend::new(&quot;images/split-drawing-area.png&quot;, (640, 480)).into_drawing_area();

    // We can split to left panel and right panel 25% left, 75% right
    let (left, right) = root.split_horizontally((25).percent_width());

    left.fill(&amp;YELLOW).unwrap();

    // We can also split upper and lower panel
    let (upper, lower) = right.split_vertically(240);
    upper.fill(&amp;BLUE).unwrap();

    // Then we can split the lower area evenly to 3 row 2 col
    let lower_areas = lower.split_evenly((2, 3));

    for (id, area) in lower_areas.into_iter().enumerate() {
        area.fill(&amp;Palette99::pick(id)).unwrap();
    }
}
</code></pre></pre>
<p><img src="basic/../../images/split-drawing-area.png" alt="split-drawing-area" /></p>
<h2><a class="header" href="#creating-multi-panel-figures" id="creating-multi-panel-figures">Creating multi-panel figures</a></h2>
<p>With child drawing area, we can easily render multi-panel figures. Here's an example for making multi-panel figures: </p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;

fn main() {
    let root = BitMapBackend::new(&quot;images/multi-panel-figure.png&quot;, (640, 480)).into_drawing_area();
    root.fill(&amp;WHITE).unwrap();
    let (upper, lower) = root.split_vertically((80).percent());

    let mut upper_chart = ChartBuilder::on(&amp;upper)
        .set_label_area_size(LabelAreaPosition::Left, 30)
        .set_label_area_size(LabelAreaPosition::Right, 30)
        .set_label_area_size(LabelAreaPosition::Top, 30)
        .build_cartesian_2d(0.0..10.0, -1.0..1.0)
        .unwrap();
    upper_chart.configure_mesh().draw().unwrap();

    upper_chart.draw_series(LineSeries::new(
        (0..100).map(|x| x as f64 / 10.0).map(|x| (x, x.sin())),
        &amp;BLACK,
    )).unwrap();

    let mut lower_chart = ChartBuilder::on(&amp;lower)
        .set_label_area_size(LabelAreaPosition::Left, 30)
        .set_label_area_size(LabelAreaPosition::Right, 30)
        .build_cartesian_2d(0.0..10.0, -1.0..1.0)
        .unwrap();
    lower_chart.configure_mesh().draw().unwrap();
    
    lower_chart.draw_series(
        (0..100)
            .map(|x| x as f64 / 10.0)
            .map(|x| {
                let color = if x.cos() &gt; 0.0 { RED.mix(0.3).filled() } else {GREEN.mix(0.3).filled()};
                Rectangle::new([(x, 0.0), (x + 0.1, x.cos())], color)
            })
    ).unwrap();
}
</code></pre></pre>
<p><img src="basic/../../images/multi-panel-figure.png" alt="multipanel" /></p>
<h1><a class="header" href="#draw-3d-plots" id="draw-3d-plots">Draw 3D plots</a></h1>
<p>Plotters also allows rendering 3D figures. Instead of using <code>build_cartesian_2d</code>, 3D plots are build with <code>ChartBuilder</code> by calling <code>build_cartesian_3d</code> method.  Similar to the 2D figures, Plotters also can draw basic components for 3D charts. </p>
<h2><a class="header" href="#3d-plotting-environment--basic-figure-component" id="3d-plotting-environment--basic-figure-component">3D plotting environment &amp;&amp; basic figure component</a></h2>
<p>This following example demonstrate how to build a basic 3d plotting environment. Unlike 2d chart context, you need to configure <code>configure_axes</code> to build the basic component.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;
fn main() {
    let root = BitMapBackend::new(&quot;images/3d-env.png&quot;, (640, 480)).into_drawing_area();

    root.fill(&amp;WHITE).unwrap();

    let mut chart = ChartBuilder::on(&amp;root)
        .margin(20)
        .caption(&quot;Empty 3D Figure&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_3d(0.0..1.0, 0.0..1.0, 0.0..1.0)
        .unwrap();
    chart.configure_axes().draw().unwrap();
}
</code></pre></pre>
<p><img src="basic/../../images/3d-env.png" alt="3d-env.png" /></p>
<h2><a class="header" href="#draw-a-line-series" id="draw-a-line-series">Draw a line series</a></h2>
<p>In 3D plotting environment, you can draw a line series in the same way. </p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;
fn main() {
    let root = BitMapBackend::new(&quot;images/3d-line.png&quot;, (640, 480)).into_drawing_area();

    root.fill(&amp;WHITE).unwrap();

    let mut chart = ChartBuilder::on(&amp;root)
        .margin(20)
        .caption(&quot;3D Line&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_3d(-1.0..1.0, -1.0..1.0, -1.0..1.0)
        .unwrap();
    chart.configure_axes().draw().unwrap();

    chart.draw_series(LineSeries::new(
        (-100..100).map(|y| y as f64 / 100.0).map(|y| ((y * 10.0).sin(), y, (y * 10.0).cos())),
        &amp;RED
    )).unwrap();
}
</code></pre></pre>
<p><img src="basic/../../images/3d-line.png" alt="3d-env.png" /></p>
<h2><a class="header" href="#draw-a-3d-bar-chart" id="draw-a-3d-bar-chart">Draw a 3D bar chart</a></h2>
<p><strong>Note: This is currently only avaiable with developement version of plotters</strong></p>
<p>Next, we are going to deomonstrate Plotters' 3D elements. We use the <code>Cubiod</code> 3D element to build a 3D bar chart. </p>
<pre><pre class="playpen"><code class="language-rust">use plotters_master::prelude::*;
fn main() {
    let root = BitMapBackend::new(&quot;images/3d-bar.png&quot;, (640, 480)).into_drawing_area();

    root.fill(&amp;WHITE).unwrap();

    let mut chart = ChartBuilder::on(&amp;root)
        .margin(20)
        .caption(&quot;3D Bar&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_3d(0i32..10, -10i32..10, 0i32..10)
        .unwrap();
    chart.configure_axes().draw().unwrap();

    chart.draw_series(
        (0i32..10i32)
            .map(|x| std::iter::repeat(x).zip(0i32..10))
            .flatten()
            .map(|(x,z)| {
                Cubiod::new([(x, 0, z), (x + 1, x - z, z + 1)], BLUE.filled(), &amp;BLACK)
            })
    ).unwrap();
}
</code></pre></pre>
<p><img src="basic/../../images/3d-bar.png" alt="3d-env.png" /></p>
<h2><a class="header" href="#3d-surface" id="3d-surface">3D Surface</a></h2>
<p>We can draw 3d surface as well by drawing a series of polygon. Here's an example of how to draw a surface plot.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;
fn main() {
    let root = BitMapBackend::new(&quot;images/3d-surface.png&quot;, (640, 480)).into_drawing_area();

    root.fill(&amp;WHITE).unwrap();

    let mut chart = ChartBuilder::on(&amp;root)
        .margin(20)
        .caption(&quot;3D Surface&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_3d(-3.0..3.0, -3.0..3.0, -3.0..3.0)
        .unwrap();

    chart.configure_axes().draw().unwrap();

    let mut data = vec![];
    
    for x in (-25..25).map(|v| v as f64 / 10.0) {
        let mut row = vec![];
        for z in (-25..25).map(|v| v as f64 / 10.0) {
            row.push((x, (x * x + z * z).cos(), z));
        }
        data.push(row);
    }

    chart.draw_series(
        (0..49)
            .map(|x| std::iter::repeat(x).zip(0..49))
            .flatten()
            .map(|(x,z)| {
                Polygon::new(vec![
                    data[x][z],
                    data[x+1][z],
                    data[x+1][z+1],
                    data[x][z+1],
                ], &amp;BLUE.mix(0.3))
            })
    ).unwrap();

}
</code></pre></pre>
<p><img src="basic/../../images/3d-surface.png" alt="surface" /></p>
<h3><a class="header" href="#drawing-with-surface-series" id="drawing-with-surface-series">Drawing with surface series</a></h3>
<p><strong>Note: This feature is only avaiable in development version</strong></p>
<pre><pre class="playpen"><code class="language-rust">use plotters_master::prelude::*;
fn main() {
    let root = BitMapBackend::new(&quot;images/3d-surface-series.png&quot;, (640, 480)).into_drawing_area();

    root.fill(&amp;WHITE).unwrap();

    let mut chart = ChartBuilder::on(&amp;root)
        .margin(20)
        .caption(&quot;3D Surface&quot;, (&quot;sans-serif&quot;, 40))
        .build_cartesian_3d(-3.0..3.0, -3.0..3.0, -3.0..3.0)
        .unwrap();

    chart.configure_axes().draw().unwrap();
    
    chart.draw_series(SurfaceSeries::xoz(
        (-25..25).map(|v| v as f64 / 10.0), 
        (-25..25).map(|v| v as f64 / 10.0), 
        |x:f64,z:f64|(x * x + z * z).cos()).style(&amp;BLUE.mix(0.2))
    ).unwrap();

}
</code></pre></pre>
<p><img src="basic/../../images/3d-surface-series.png" alt="surface" /></p>
<h2><a class="header" href="#customize-perspective-matrix" id="customize-perspective-matrix">Customize perspective matrix</a></h2>
<p>Plotters also allows user override the default prespective matrix, by doing so, you can zoom and rotate the 3d figure. The following example demostrate how. </p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;
fn main() {
    let root = BitMapBackend::new(&quot;images/3d-matrix.png&quot;, (640, 480)).into_drawing_area();

    root.fill(&amp;WHITE).unwrap();

    let mut chart = ChartBuilder::on(&amp;root)
        .margin(20)
        .build_cartesian_3d(-1.0..1.0, -1.0..1.0, -1.0..1.0)
        .unwrap();

    // You need configure the projection matrix before start drawing anything
    chart.with_projection(|mut pb| {
        pb.pitch = 1.2;
        pb.yaw = 0.5;
        pb.scale = 0.7;
        pb.into_matrix()
    });
    chart.configure_axes().draw().unwrap();
    chart.draw_series(LineSeries::new(
        (-100..100).map(|y| y as f64 / 100.0).map(|y| ((y * 10.0).sin(), y, (y * 10.0).cos())),
        &amp;RED
    )).unwrap();

}
</code></pre></pre>
<p><img src="basic/../../images/3d-matrix.png" alt="matrix" /></p>
<h1><a class="header" href="#animation-and-realtime-rendering" id="animation-and-realtime-rendering">Animation and realtime rendering</a></h1>
<p>All the previous examples is static rendered images, in this part, we are going to show how to generate realtime or animated plots. To render a realtime or animated figure, you need to redraw the figure periodically: For a animated plot, you should render each frame, while for a GUI integration, you should handle the redraw request.</p>
<p>The realtime rendering semantics for Plotters is supported by the API <code>DrawingBackend::present</code>, which means we tell the drawing backend we are finishing drawing the current frame. The following drawing will belongs to the next frame. </p>
<p>At the same time, you need a backend that supports realtime rendering. When GIF support is enabled, the default <code>BitMapBackend</code> is able to produce animated images. The following example shows show. </p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;
fn main() {
    let area = BitMapBackend::gif(
        &quot;images/animated.gif&quot;, 
        (320, 100), 
        1_000  /* Each frame show 1s */
    ).unwrap().into_drawing_area();
    for i in 0..=10 {
        area.fill(&amp;WHITE).unwrap();
        area.draw(
            &amp;Text::new(
                format!(&quot;{}&quot;, 10 - i), 
                (100, 20),
                (&quot;sans-serif&quot;, 80)
            )
       ).unwrap();
       area.present().unwrap();
    }
}
</code></pre></pre>
<p><img src="basic/../../images/animated.gif" alt="animated" /></p>
<p>Similarly when Plotters is integrated to a GUI framework, all you need to do is redraw the figure and call <code>present</code> after the plot rendering.</p>
<h1><a class="header" href="#tweaking-the-figure" id="tweaking-the-figure">Tweaking the figure</a></h1>
<p>In previous parts, we learned how to create data visualization with Plotters. In this part, we are going to show how to customize the data visualization and tweak the plot appearance. </p>
<h1><a class="header" href="#layout-tweaks" id="layout-tweaks">Layout Tweaks</a></h1>
<h2><a class="header" href="#label-area-size" id="label-area-size">Label area size</a></h2>
<p>To build a chart in Plotters, you need first define the axis specification and the dimension of the label areas. When a <code>ChartBuilder</code> is created, the label area size is set to 0, which means Plotters shouldn't draw the axis and tick marks. You can tweak the label area size with <code>ChartBuilder::set_label_area_size</code>.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;
fn main() {
    let root = BitMapBackend::new(&quot;images/label-area-size.png&quot;, (640, 480)).into_drawing_area();

    root.fill(&amp;WHITE).unwrap();

    let (left, right) = root.split_horizontally(320);

    let mut left_chart = ChartBuilder::on(&amp;left)
        .margin(15)
        .set_label_area_size(LabelAreaPosition::Left, 30)
        .set_label_area_size(LabelAreaPosition::Bottom, 30)
        .build_cartesian_2d(0..100, 0..100)
        .unwrap();
    let mut right_chart = ChartBuilder::on(&amp;right)
        .margin(15)
        .set_label_area_size(LabelAreaPosition::Right, 30)
        .set_label_area_size(LabelAreaPosition::Bottom, 50)
        .build_cartesian_2d(0..100, 0..100)
        .unwrap();

    left_chart.configure_mesh().draw().unwrap();
    right_chart.configure_mesh().draw().unwrap();
}
</code></pre></pre>
<p><img src="tweak/../../images/label-area-size.png" alt="label-area-size" /></p>
<h2><a class="header" href="#floating-label-area" id="floating-label-area">Floating label area</a></h2>
<p>Sometimes we want our axis is drawn on the top of the plot area, this can be done if you set label area size to negative.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;
fn main() {
    let root = BitMapBackend::new(&quot;images/axis-overlapping-with-plot.png&quot;, (640, 480)).into_drawing_area();
    
    root.fill(&amp;WHITE).unwrap();
    
    let mut chart = ChartBuilder::on(&amp;root)
        .margin(15)
        .set_label_area_size(LabelAreaPosition::Left, -300)
        .set_label_area_size(LabelAreaPosition::Top, -30)
        .build_cartesian_2d(0..100, 0..100)
        .unwrap();
    chart.configure_mesh()
    .set_tick_mark_size(LabelAreaPosition::Left, 5)
    .draw().unwrap();
}
</code></pre></pre>
<p><img src="tweak/../../images/axis-overlapping-with-plot.png" alt="label-area-size" /></p>
<h2><a class="header" href="#overlapped-charts" id="overlapped-charts">Overlapped charts</a></h2>
<p>We have learned how to split the parent drawing area into some sub-drawing-area. But in some case, we want to intentionally set one chart on the top of another. This can be done by <code>DrawingArea::shirnk</code>. The following example demonstrates how.</p>
<pre><pre class="playpen"><code class="language-rust">use plotters::prelude::*;
fn main() {
    let root = BitMapBackend::new(&quot;images/overlapped.png&quot;, (640, 480)).into_drawing_area();
    
    root.fill(&amp;WHITE).unwrap();
    
    let small_area = root.clone().shrink(
        (300, 300),
        (100, 100)
    );
    let mut chart = ChartBuilder::on(&amp;root)
        .margin(15)
        .set_label_area_size(LabelAreaPosition::Left, 30)
        .set_label_area_size(LabelAreaPosition::Bottom, 30)
        .build_cartesian_2d(0..100, 0..100)
        .unwrap();
    chart.configure_mesh().disable_mesh().draw().unwrap();

    let mut small_chart = ChartBuilder::on(&amp;small_area)
        .set_label_area_size(LabelAreaPosition::Left, 15)
        .set_label_area_size(LabelAreaPosition::Bottom, 15)
        .build_cartesian_2d(0..10, 0..10)
        .unwrap();
    small_chart.configure_mesh().draw().unwrap();
}
</code></pre></pre>
<p><img src="tweak/../../images/overlapped.png" alt="overlapped" /></p>
<h1><a class="header" href="#font-color-and-styles" id="font-color-and-styles">Font, color and styles</a></h1>
<h1><a class="header" href="#axis-mesh-and-label-tweaks" id="axis-mesh-and-label-tweaks">Axis, mesh and label tweaks</a></h1>
<ul>
<li>Adjust number of tick marks on axis</li>
<li>Changing axis, labels and mesh styles</li>
<li>Partially visible axis</li>
<li>Label formatters</li>
<li>Inward labels</li>
<li>Log scale axis</li>
</ul>
<h1><a class="header" href="#relative-sizing" id="relative-sizing">Relative sizing</a></h1>
<h1><a class="header" href="#drawing-apis" id="drawing-apis">Drawing APIs</a></h1>
<h1><a class="header" href="#drawing-areas" id="drawing-areas">Drawing areas</a></h1>
<h1><a class="header" href="#elements" id="elements">Elements</a></h1>
<h1><a class="header" href="#coordinate-systems" id="coordinate-systems">Coordinate systems</a></h1>
<h1><a class="header" href="#1d-coordinates" id="1d-coordinates">1D coordinates</a></h1>
<h1><a class="header" href="#high-dimensional-coordinates" id="high-dimensional-coordinates">High dimensional coordinates</a></h1>
<h1><a class="header" href="#coordinate-combinators" id="coordinate-combinators">Coordinate combinators</a></h1>
<h1><a class="header" href="#targeting-different-backends" id="targeting-different-backends">Targeting different backends</a></h1>
<h1><a class="header" href="#drawing-backends" id="drawing-backends">Drawing backends</a></h1>
<h1><a class="header" href="#html5-canvas" id="html5-canvas">HTML5 Canvas</a></h1>
<h1><a class="header" href="#framebuffer" id="framebuffer">Framebuffer</a></h1>
<h1><a class="header" href="#performance" id="performance">Performance</a></h1>
<h1><a class="header" href="#parallel-rendering-with-bitmap-blit" id="parallel-rendering-with-bitmap-blit">Parallel Rendering with Bitmap Blit</a></h1>
<h1><a class="header" href="#inplace-parallel-rendering" id="inplace-parallel-rendering">Inplace Parallel Rendering</a></h1>
<h1><a class="header" href="#incremental-rendering" id="incremental-rendering">Incremental Rendering</a></h1>
<h1><a class="header" href="#extend-plotters" id="extend-plotters">Extend Plotters</a></h1>
<h1><a class="header" href="#adding-coordinate-type" id="adding-coordinate-type">Adding coordinate type</a></h1>
<h1><a class="header" href="#adding-series-types" id="adding-series-types">Adding series types</a></h1>
<h1><a class="header" href="#support-new-backend" id="support-new-backend">Support new backend</a></h1>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<h1><a class="header" href="#supported-backends" id="supported-backends">Supported backends</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
